# -*- coding: utf-8 -*-
"""Копия блокнота "Практика 0.8.0.ipynb"

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AFLjAqM5U07dDYQvutyx9JtFCpphpvPZ

# Задание 1
"""

pip install requests

"""Задача: Создать чат бота для получения информации об исследованиях космоса

Описание: Создайте комплексное приложение командной строки, которое будет использоваться в качестве панели управления исследованиями космоса. Данное приложение будет обращаться к https://api.nasa.gov/ для предоставления пользователям набора информации о космосе, включая:

- Астрономическая картинка дня (APOD): Отображение APOD с пояснениями к нему.
- Фотографии с марсохода: позволяет пользователям выбирать и фильтровать фотографии с марсохода по дате и типу камеры.
- Объекты, сближающиеся с Землей (ОСЗ): Поиск и отображение информации об объекте, сближающихся с Землей, на определенную дату, включая их размеры и потенциальную опасность.
- Данные о космической погоде: Отображают последние данные о космической погоде, включая солнечные вспышки и геомагнитные бури.
Приложение должно позволять пользователям ориентироваться в этих функциях, корректно обрабатывать ошибки и обеспечивать удобство работы.

Требования:
- Пользовательский ввод: Приложение должно предложить пользователю ввести данные, чтобы выбрать, какую функцию он хочет изучить.
- Проверка данных: Убедитесь, что пользовательские данные (например, даты) проверены.
- Обработка ошибок: Корректно обрабатывайте ошибки API и неверные ответы.
- Представление данных: Представляйте данные в четкой и организованной форме.
- Опция выхода: позволяет пользователям выходить из приложения в любое время.
"""

import requests

def send_request(url):
    response = requests.get(url)
    status_code = response.status_code
    print(status_code)
    if status_code == 200:
        return response.json()
    return None



url2 = f'https://api.nasa.gov/planetary/apod?api_key=J8VnTTdjb7uGThDWkPdqKf9FWTeb1rgCvRnhJboq'
print(send_request(url2))


def mars_rover_photos(url)
    response =

import requests
from datetime import datetime


API_KEY = 'J8VnTTdjb7uGThDWkPdqKf9FWTeb1rgCvRnhJboq'

def get_apod():
    url = f"https://api.nasa.gov/planetary/apod?api_key={API_KEY}"
    response = requests.get(url)

    if response.status_code == 200:
        data = response.json()
        print(f"Дата: {data['date']}")
        print(f"Название: {data['title']}")
        print(f"Описание: {data['explanation']}")
        print(f"Ссылка на изображение: {data['url']}")
    else:
        print(f"Ошибка API (APOD): {response.status_code}")


def get_mars_photos(sol, camera):
    url = f"https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?sol={sol}&camera={camera}&api_key={API_KEY}"
    response = requests.get(url)

    if response.status_code == 200:
        data = response.json()
        photos = data.get('photos', [])

        if photos:
            for photo in photos:
                print(f"Дата: {photo['earth_date']}, Ссылка на изображение: {photo['img_src']}")
        else:
            print("Фотографий не найдено для указанных параметров.")
    else:
        print(f"Ошибка API (Mars Photos): {response.status_code}")


def get_near_earth_objects(date):
    url = f"https://api.nasa.gov/neo/rest/v1/feed?start_date={date}&end_date={date}&api_key={API_KEY}"
    response = requests.get(url)

    if response.status_code == 200:
        data = response.json()
        for element in data['near_earth_objects'][date]:
            name = element['name']
            size = element['estimated_diameter']['kilometers']['estimated_diameter_max']
            is_hazardous = element['is_potentially_hazardous_asteroid']
            print(f"Объект: {name}, Размер: {size:.2f} км, Потенциально опасный: {'Да' if is_hazardous else 'Нет'}")
    else:
        print(f"Ошибка API: {response.status_code}")


def get_space_weather():
    url = "https://api.nasa.gov/DONKI/GST?api_key={API_KEY}"
    response = requests.get(url)

    if response.status_code == 200:
        data = response.json()
        if data:
            for event in data:
                print(f"Дата: {event['startTime']}, Событие: {event['activity']}")
        else:
            print("Нет данных о космической погоде.")
    else:
        print(f"Ошибка API (Space Weather): {response.status_code}")


def main():
    while True:
        print("\nВыберите опцию:")
        print("1. Астрономическая картинка дня (APOD)")
        print("2. Фотографии с марсохода")
        print("3. Объекты, сближающиеся с Землей (ОСЗ)")
        print("4. Данные о космической погоде")
        print("5. Выход")

        choice = input("Введите номер опции: ")

        if choice == "1":
            get_apod()
        elif choice == "2":
            sol = input("Введите SOL (дата на марсе): ")
            camera = input("Введите тип камеры (например, 'FHAZ', 'RHAZ', 'NAVCAM', 'CHEMCAM'): ")
            get_mars_photos(sol, camera)
        elif choice == "3":
            date = input("Введите дату (YYYY-MM-DD): ")
            try:
                datetime.strptime(date, '%Y-%m-%d')
                get_near_earth_objects(date)
            except ValueError:
                print("Неверный формат даты. Пожалуйста, укажите дату в формате YYYY-MM-DD.")
        elif choice == "4":
            get_space_weather()
        elif choice == "5":
            print("Выход из приложения.")
            break
        else:
            print("Неверный выбор. Пожалуйста, выберите корректный номер опции.")


if __name__ == "__main__":
    main()

"""# Задание 2

Описание задачи

Цель этой задачи - создать скрипт на Python, который взаимодействует с API Чикагского института искусств (https://api.artic.edu/docs/) для извлечения и отображения произведений искусства. Скрипт должен позволять пользователям просматривать работы по страницам, фильтровать их по имени художника и просматривать подробную информацию о выбранных произведениях искусства. Ниже приведены требования и функциональные возможности, которые необходимо реализовать:

Требования:
Извлекать произведения искусства:

- Создайте функцию, которая извлекает список произведений искусства из API Чикагского института искусств.
Функция должна принимать параметр page для разбивки на страницы и возвращать список произведений искусства вместе с информацией о разбивке на страницы.
Фильтровать произведения искусства:

- Реализуйте функцию, которая фильтрует список произведений искусства на основе имени указанного художника. Функция должна возвращать список работ, которые соответствуют имени художника (без учета регистра).
Отображать подробную информацию об оформлении:

- Напишите функцию, которая отображает названия работ для пользователя и позволяет ему выбрать одну из них, введя соответствующий номер.
После выбора функция должна отображать подробную информацию о выбранном произведении, включая название, исполнителя, дату и носитель.
Разбивка на страницы и взаимодействие с пользователем:

- Создайте основную функцию, которая управляет выборкой произведений и взаимодействием с пользователем.

Разрешите пользователям перемещаться по страницам с произведениями искусства, выполнять фильтрацию по исполнителю или выходить из программы.

Если страниц с произведениями искусства несколько, укажите варианты перехода к следующей странице, предыдущей странице, фильтрации по исполнителю или выхода из программы.
"""

import requests

API_URL = "https://api.artic.edu/api/v1/artworks"

def fetch_artworks(page=1):
    params = {
        "page": page,
        "limit": 10
    }
    response = requests.get(API_URL, params=params)

    if response.status_code == 200:
        data = response.json()
        return data['data'], data['pagination']
    else:
        print(f"Ошибка API: {response.status_code}")
        return None, None

def filter_artworks_by_artist(artworks, artist_name):
    filtered_artworks = [
        artwork for artwork in artworks
        if 'artist_title' in artwork and artist_name.lower() in artwork['artist_title'].lower()
    ]
    return filtered_artworks

def display_artwork_info(artwork):
    title = artwork.get('title', 'Без названия')
    artist = artwork.get('artist_title', 'Неизвестный художник')
    date = artwork.get('date_display', 'Неизвестная дата')
    medium = artwork.get('medium_display', 'Неизвестный носитель')

    print(f"\nНазвание: {title}")
    print(f"Исполнитель: {artist}")
    print(f"Дата: {date}")
    print(f"Носитель: {medium}\n")

def main():
    current_page = 1
    while True:
        artworks, pagination = fetch_artworks(current_page)

        if artworks is None:
            break

        print(f"\nСтраница {current_page} из {pagination['total_pages']}")
        print("Произведения искусства:")

        for i, artwork in enumerate(artworks, start=1):
            print(f"{i}. {artwork.get('title', 'Без названия')}")

        print("\nОпции:")
        print("1. Просмотреть подробности о произведении.")
        print("2. Фильтровать по имени художника.")

        if pagination['has_next_page']:
            print("3. Следующая страница.")
        if pagination['has_previous_page']:
            print("4. Предыдущая страница.")

        print("5. Выход.")

        choice = input("Выберите опцию (1-5): ")

        if choice == '1':
            artwork_index = int(input("Введите номер произведения: ")) - 1
            if 0 <= artwork_index < len(artworks):
                display_artwork_info(artworks[artwork_index])
            else:
                print("Неверный номер произведения.")

        elif choice == '2':
            artist_name = input("Введите имя художника: ")
            filtered_artworks = filter_artworks_by_artist(artworks, artist_name)
            if filtered_artworks:
                print("\nФильтрованные произведения:")
                for i, artwork in enumerate(filtered_artworks, start=1):
                    print(f"{i}. {artwork.get('title', 'Без названия')}")
            else:
                print("Произведения не найдены.")

        elif choice == '3' and pagination['has_next_page']:
            current_page += 1

        elif choice == '4' and pagination['has_previous_page']:
            current_page -= 1

        elif choice == '5':
            print("Выход из программы.")
            break

        else:
            print("Неверный выбор или недоступная опция.")

if __name__ == "__main__":
    main()

"""# Задание 3

Задача: Создать программу по управлению портфелем криптовалют

Цель: Создать скрипт на Python, который извлекает цены на криптовалюты в режиме реального времени, позволяет пользователям управлять портфелем криптовалют, вычисляет общую стоимость портфеля, отслеживает изменения цен и предоставляет исторические данные о ценах для анализа.

Требования:
Получение текущих цен на криптовалюты:

Используйте https://docs.coingecko.com/ для получения актуальных цен на список криптовалют.

Управление портфелем:

- Позволяет пользователю создавать портфель криптовалют и управлять им, указывая количество каждой криптовалюты, которой он владеет.
- Расчитывает общую стоимость портфеля в указанной фиатной валюте (например, долларах США).

Отслеживание изменения цен:

- Отображение процентного изменения цены для каждой криптовалюты в портфеле за последние 24 часа.
- Выделите все криптовалюты, стоимость которых значительно увеличилась или снизилась.

Поиск исторических данных о ценах:

- Получение исторических данных о ценах на указанную криптовалюту за последнюю неделю.
- Предоставьте пользователю возможность визуализировать эти данные в простом текстовом формате (например, цены за день).

Взаимодействие с пользователем:

- Реализуйте интерфейс командной строки для ввода данных пользователем.
- Предоставьте опции для получения текущих цен, управления портфелем, просмотра изменений цен или анализа исторических данных.
"""



"""# Дополнительно: Задание 4

Задание 4: Проектное

Вам необходимо самостоятельно найти откртое API предоставляющее информацию в открытом доступе и реализовать собственный проект!


Критерии приемки результата:

- Проект включает в себя не менее 5 возможостей для пользователя
- Проект позволяет использовать все возможности проекта пользователю при помощи взаимодействия через коммандную строку
- Проект работает с открытым API (это значит что при проверке вашей работы преподавателем, преподавателю необходимо просто запустить ячейку с кодом вашего проекта и она будет работать без дополнительных манипуляции)
- Проект должен обязательно включать в себя ряд используемых конструкции:
    - Функции
    - Условные конструкции
    - Ввод/вывод
    - Словари/Списки
- Допускается использование библиотек:
    - requests
    - datetime
    - random

**Здесь добавьте описание вашего проекта**
"""

#  А здесь код